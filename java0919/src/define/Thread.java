package define;

public class Thread {
/*
  
  ** programs, process, thread 
   => task: process 와 thread를 합쳐서 부르는 용어 
   => program: 동일한 작업을 하기 위해 모인 파일의 집합 
   => process: 실행 중인 프로그램, 자신의 작업이 종료 될때 까지 다른 process에게 제어권을 
   넘기지 않습니다. 실행 중인 동안에는 다른 프로세스의 작업을 할 수 없습니다. 
   다른 프로세스를 실행하려면 프로세서가 2개 이상 있어야 합니다. 
   2개 이상의 프로세서(CPU)를 가지고 여러 개의 프로세스를 실행하는 것을 병렬처리라고 합니다. 
   =>thread: process안에 존재하는 작업의 단위 
   process의 작업을 분할해서 자신의 작업을 수행하는 도중에 쉬는 시간이 생기면 또는 
   일정한 시간 단위로 다른 thread의 작업을 수행할 수 있습니다. 
   마치 여러 개의 작업을 동시에 처리하는 것 처럼 보여지기도 합니다. 
   일반 메소드 호출은 process 형태로 동작합니다. 
   
  1. java에서 Thread를 생성하는 방법 
  1)Thread클래스를 상속받는 방법 
  =>Thread클래스를 상속받는 클래스를 생성하고 run메소드에 스레드로 수행할 내용을 작성 
  => 객체를 생성하고 start()를 호출 
  
  2)Runnable 인터페이스를 구현하는 방법 
  =>Runnable인터페이스를 구현한 클래스를 만들고 run메소드에 스레드로 수행할 내용을 작성 
  =>객체를 생성 
  =>Thread클래스의 객체를 만드는데 이 때 앞에서 만든 객체를 생성자에 대입 
  =>Thread클래스의 객체가 start()를 호출 
  
  3) 보통은 Thread클래스를 상속받지만 이 클래스가 다른 클래스를 상속하는 경우에는 Runnable 
  인터페이스를 구현. java는 다중상속이 안됨  
  
 2.Thread클래스 
 1) 생성자  
Thread(): 이름을 시스템이 생성 

Thread(Runnable target): Runnable인터페이스 객체를 가지고 스레드를 생성 

Thread(Runnable target, String name): 스레드 이름까지 같이 받아서 만드는 생성 

Thread(String name)
 
 2) 메소드 
 interrupt(): 스레드에 인터럽트 메세지를 전송 
 
  setDaemon(boolean daemon): 데몬 스레드 설정을 위한 메소드 
  
  start(): 스레드를 시작 
  
  run(): 스레드로 수행할 내용을 가지는 메소드 
  
  static sleep(int millisecond): 스레드의 작업을 일시 중지 
  
 3. 상속 방법 
 1) 상속받는 클래스를 만들고 객체를 생성  - 동일한 내용을 갖는 객체를 여러 개 생성가능 
 class 클래스이름 extends 상위클래스 이름 {
 
 }
 
 클래스이름 변수 = new 클래스이름();
 
  2)객체를 바로 생성 - 동일한 내용을갖는 객체를 1개만 생성 
  상위클래스이름 변수 = new 상위클래스이름(){
  
  }; 

 4.daemon thread 
 =>스레드를 분류하는 방법 중에worker thread와 daemon thread로 분류하는 경우도 있습니다. 
 =>worker thread는 자신의 작업이 종료될 때까지 무조건 수행을 계속합니다. 
     daemon thread는 다른 worker thread가 없으면 자동으로 작업을 중지합니다. 
=> 중요하지 않은 작업이나 백그라운드에서 수행해야 하는 작업들을 daemon으로 만들면 
다른 스레드가 없으면 자동으로 중지 되므로 편리합니다.   
=> 오랜 시간이 걸리는 다운로드 작업 같은 경우 worker thread로 만들면 다운로드가 끝날 때 까지 
프로세스는 계속 동작해야 합니다. 
이런 작업을 daemon thread로 만들면 다른 작업이 중지되면 자동으로 중지됩니다. 
=>daemon 스레드 만드는 방법은 start()를 호출하기 전에 setDaemon 메소드에 true를 대입하면 됩니다. 
=>서버와 통신하는 부분들을 데몬으로 만드는 경우가 많습니다. 
 다음에 사용할 데이터를 다운로드 받는 부분을 데몬으로 만들면 일을 하다가 멈추면 자동으로 
 다운로드가 중지됩니다. 
 데몬으로 만들지 않으면 프로그램을 종료할 때 일일이 스레드를 전부 종료 시켜야 합니다. 
 바로 사용해야 하는 데이터가 아닌 데이터를 다운로드 받을때는 데몬스레드로 만드는 것이 좋습니다. 
 
 5. 스레드의 우선 순위 
 =>스레드들 사이의 우선순위를 설정해서 특정 스레드가 자주 또는 먼저 수행하도록 할 수 있습니다.
 =>우선수위 설정과 확인은 setPriority(설정) 와 getPriority(확인)메소드를 이용  
 => 설정은 정수로 하는데 Thread클래스의 static final상수를 이용하는 게 좋습니다. 
 MAX_PRIOIRITY 
 MIN_PRIORITY
 NORM_PRIORITY 
 =>windows는 우선순위가 1-10까지 인데 Linux는 1-7까지 입니다. 
 우선순위를 정수를 이용해서 직접 10이라고 설정하면 windows에서는 제대로 인식을 하지만 
 Linux에서는 인식을 하지 못합니다.
 Thread.MAX_PRIORITY로 설정하면 windows에서는 10 Linux에서는 7로 설정이 됩니다.
 =>매개변수가 int라고 아무 정수나 대입하면 안됩니다.
 옵션일 때는 클래스에 적용할 final field가 있는지 확인해야 합니다. 
 =>우선순위가 높다고 무조건 먼저 수행되거나 자주 수행되지는 않습니다. 
 먼저 되거나 자주 수행될 가능성이 높아지는 것이지 절대적인 개념은 아닙니다. 
 
 6.Thread 의 종료 
 1) daemon스레드의 경우는 다른 worker스레드가 없으면 종료 
 2) run메소드의 내용을 전부 수행해서 return하는 경우 
 3)강제로 종료를 시키고자 할때는 run메소드안에 예외처리 구문을 만들고 InterruptedException
 이 발생하면 return하도록 코드를 작성 
 스레드 객체가 interrupt()를 호출하면 스레드가 강제로 종료됩니다. 
 
 7.Thread의 실행 제어 
 join(밀리초-1/1000, 나노초 - 1/1000000000): 설정한 시간동안 스레드를 수행 
 =>pc용 운영체제는 1/50초 정도까지 밖에 인식을 하지 못합니다. 
 
 suspend():스레드를 일시 중지 
 
 resume():suspend된 스레드를 동작시키는 것 
 
 yield(): 다른 스레드에게 실행 상태를 양보하고 자신은 준비 상태로 변경 
 
 => 위와 같은 메소드들은 시분할 프로그래밍(일정한 시간단위로 분할해서 작업을 수행) 에서 이용 
 공장자동화 제어 같은 분야가 시분할의 대표적인 사례 
 
  !!! 스레드를 생성과 시작 그리고 daemon이 중요  
  
8. Multi Thread 
=>2개 이상의 스레드가 동작 중인 경우 
=> 최적의 개수를 고려해야 합니다. 
스레드가 자신의 작업을 수행하다가 제어권을 다른 스레드로 넘기는 경우 현재까지 작업한 내역을 
저장하고 다른 스레드의 작업한 내역을 읽어서 실행합니다. 
스레드가 자신의 작업을 완료하지 않은 상태에서 다른 스레드를 실행하려고 하면 오버헤드(실제 작업
한 부분을 제외한 것)가 발생 

=>Multi Exclusion(상호 배제)
하나의 스레드가 수정할 목적으로 사용 중인 공유 데이터는 다른 스레드가 수정할 수 없도록 해야 합니다. 

=> 생산자와 소비자 문제 
자원을 생성하는 스레드와 소비하는 스레드가 동시에 동작하는 경우 소비하는 스레드는 생성하는 
스레드가 자원을 만든 후에 동작해야 합니다. 

=>Dead Lock(교착상태) 
스레드들이 서로 자신의 자원을 가진 상태에서 다른 스레드에게 자원을 요청하는 경우가 발생하면 
작업의 수행이 이루어지지 않고 무한대기 상태가 될 수 있습니다.
이러한 상태를 교착상태라고 합니다. 

 9. 상호배제 
 1)32bit시스템에서 64bit데이터를 사용할 때 발생할 수 있는 문제를 해결할 때는 변수앞에 vilatile
 을 적용 
 
 64bit 데이터를 수정할 때 32bit씩 나누어서 2번에 걸쳐서 수정을 하는데 이 때 일부분만 수정한 상태
 에서 다른 스레드가 이 데이터를 사용하게 되면 잘못된 결과를 사용할 수 있습니다. 
 volatile을 붙이면 이 데이터의 수정은 무조건 한번에 수행을 하게 됩니다. 
 일부분만 수정된 상태에서 이 데이터를 사용 할 수 없도록 합니다. 
 long 형 데이터에 이용 
 
 2)synchronized메소드 
 =>메소드의 결과형 앞에 synchronized를 붙이면 이 메소드는 수행의 원자성을 보장합니다.
 이 메소드 수행 중에는 다른 스레드가 이 메소드가 사용 중인 데이터를 사용할 수 없습니다.  
 
 3)synchronized블럭 
 synchronized(공유객체){
     코드 
 }
=> 블록내에서 공유객체를 사용 중이면 다른 스레드가 공유객체를 수정할 수 없도록 합니다. 
=>메소드에 synchronized를 만들면 공유도가 떨어집니다. 

4)공유 데이터를 수정하는 부분을 멀티 스레드 환경에서 사용할 때는 한번에 작업이 이루어져야 하는 
영역을 찾아서 synchronized로 묶어 주어야 합니다. 

10.생산자와 소비자 문제 
=> 하나의 스레드는 공유 데이터를 만들어내고 다른 스레드는 공유 데이터를 사용하는 경우 
공유 데이터를 만들어 내는 스레드가 공유 데이터를 만들지 않았는데 다른 스레드가 공유 데이터를 
사용하려고하면 문제가 발생합니다. 
=> 공장 자동화 에서 단계별로 작업을 분할해서 수행하는 경우가 있습니다. 
작업대는 서로 공유할 수 있는데 이 때 앞 공정에서 물건을 넘겨주지 않았는데  뒷 공정에서 작업을 
진행하려고 하면 에러가 발생 
=> 공유데이터가 없을 때 는 소비자 스레드는 대기하고 있다가 생산자 스레드가 공유데이터를 만들고 
시그널을 보내면 작업을 진행하면 됩니다. 
이 때 사용되는 메소드가 Object클래스에 있는 wait와 notify, notifyAll메소드 입니다.  

공유데이터를 소유한 클래스 (Product)
생산자 스레드 클래스 (Producer): Thread상속 
소비자 스레드 클래스메인 클래스 (Consumer): Thread 상속 
메인클래스(Thread Main?)  

=>예외가 발생해서 예외 코드를 역추적하는 부분이 출력되면 예외 추적코드 중에서 자신이  만든 클래스가
나오는 가장 윗부분으로 이동 

=> NullPointException이 발생하면 메소드를 호출한 객체가 Null이라는 것입니다. 
객체.메소드이름()이라면 객체가 Null입니다.

 =>생산자와 소비자 문제 해결 
 소비자 스레드에서는 공유자원이 없으면 대기(wait)를 해야합니다. 
 생산자 스레드는 공유자원을 만들었으면 소비자 스레드에게 이를 알려주어야(notify) 합니다.
 
  wait메소드와 notify메소드는 synchronizes에서만 사용이 가능 
  
  =>소비자 스레드로 동작해야하는 메소드는 사용할 데이터가 있는지 확인하고 없으면 대기 
  생산자스레드로 동작해야 하는 메소드는 데이터를 생성하고 나면 알림(notify)을 주어야 합니다. 
  
  자원을 제한적으로 시스템에서 생산을 할 때는 일정한 개수가 되면 더이상 생산을 하지 않도록 해주
  어야 합니다. 무한정 생산을 하다보면 자원의 제약으로 인해서 시스템이 너무 느려지기 때문입니다. 
  이 경우는 위와 반대로 소비하는 쪽에서도 알림을 주어서 소비가 되었으면 생산을 하도록 해야 합니다. 
  
  11. DeadLock
  =>무한 대기상태에 빠지는 경우 
  =>wait를 호출하고 notify를 호출하지 않는 경우에 발생할 수 있습니다. 
  => 자신이 자원을 소유한 상태에서 다른 자원을 요청하는데 다른 쪽에서 그 자원을 묶어놓고 나의 
  자원을 요청하는 경우 
  
  synchronized(x){
      y를 사용; 
  }
  
  synchronized(y){
      x를 사용;
  }
 => 이문제를 예방하기 위해서는  synchronized블럭안에서 다른 synchronized블럭 안에 있는 자원을
 사용하지 않도록 해야 합니다. 
 => 프로그램을 만들때 스레드를 사용하는 프로그램을 만드는 경우에는 synchronizes되어 있는 영역을
 다른 영역보다 코드를 주의 깊게 살펴봐야 합니다. 
문법적인 오류가 없고 예외도 발생하지 않기 때문에 에러를 찾기 어렵기 때문입니다. 

12.ThreadPool
=>ThreadGroup클래스는 여러 개의 스레드를 하나로 묶어서 사용하기 위한 개념인데 윈도우즈에서 에러가 
많이 나서 실제 사용은 거의 하지 않습니다. 
=>ThreadPool을 쉽게 만들어서 사용하도록 하는 패키지가java.util.concurrent 패키지 입니다.
=> java.util.concurrent패키지의 ExcutorService라는 인터페이스와 Excutors라는 클래스가 기능을 
제공합니다. 
1)Excutors클래스의 메소드 
newFixedThreadPool(int cnt): cnt만큼 스레드를 가질 수 있는 pool을 생성 

newCachedThreadPool():재사용 가능한 스레드 풀을 만들어  주고 60초 동안 아무일도 하지 않으면 
알아서제거합니다.

 new ThreadPoolExecutor(코어스레드개수, 최대 스레드개수, 대기시간, 시간단위, 작업큐)를 호출해서 
 생성도 가능 
  
 2) 자기CPU의 코어 개수 확인 
 Runtime클래스의 availableProcessors()를 호출하면 코어(연산장치)개수를 확인할 수 있습니다. 
 
 3)스레드 추가 
 1)번의 메소드로 생성한 ExcutorService객체에 submit(Thread객체)이용 
 
 4)스레드 풀 사용 중지
 shutdown()호출 
 
 13.Semaphore 
 => 공유자원이 여러 개일 때 상호배재(동시에 수정을 못하도록 하는 것)를 수행해서 동시에 수행할 
 스레드의 개수를 정할 수 있는 클래스 
 => ThreadPool은 상호배제를 해주지는 않습니다. 
 => 객체를 생성할 때 공유 자원의 개수를 지정해서 만듭니다., 
 Semaphore semaphore = new Semaphore(공유할 수 있는 자원의 개수); 
 
 => 스레드로 수행할 메소드 내부에서 semaphore가 공유자원을 사용하기 전에 acquire()를 호출합니다. 
 메소드를 호출하면 Lock이 만들어집니다. 
 공유자원을 전부 사용하고 나면 release()를 호출해서 Lock을 해제합니다. 
 
  => 앞에서 사용했던 synchronized는 자원 1개에 대한 상호배제만 해줍니다. 
  
  
  
  

 */
}
